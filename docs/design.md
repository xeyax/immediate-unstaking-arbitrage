1) Назначение и цель продукта

Цель: дать пользователю возможность «выйти сейчас» из стейкинга (sUSDe, wstETH и т.п.), а поставщикам ликвидности (LP) — зарабатывать на спрэде между ценой на DEX и «идеальной» ценой протокольного анстейкинга с задержкой.

Идея: когда на DEX стейк‑токен торгуется с дисконтом к протокольной цене выкупа, смарт‑контракт покупает его на DEX и оформляет официальный анстейк в базовый актив. Спустя период разлокировки (например, ~7 дней) получает полную сумму и возвращает её в пул, фиксируя прибыль для LP.

Ожидаемый результат: устойчивый «маркет‑нейтральный» доход в базовом активе (USDe/ETH), минимизируя рыночный риск цены благодаря протокольному погашению по «идеальной» цене.

⸻

2) Область применения и поддерживаемые активы

Vault разворачивается отдельно на каждый стейк‑актив:
	•	Vault‑sUSDe: базовый актив — USDe, арбитраж: sUSDe ↔ USDe.
	•	Vault‑wstETH: базовый актив — ETH, арбитраж: stETH/wstETH ↔ ETH.

(Список активов расширяемый адаптерами.)

⸻

3) Роли и аудитория
	•	LP (поставщики ликвидности): вносят базовый актив (USDe/ETH) и получают долю во Vault (шары). Доход — в том же базовом активе.
	•	Пользователи «мгновенного выхода»: это не клиенты в данном Vault; они — источник дисконта на рынке (продают стейк‑токен на DEX). Vault — контрагент, который этот дисконт выкупает.
	•	Операторы/Киперы (backend): следят за ценами/очередями, вызывают функции сделки; не могут увести средства (все проверки прибыли — в контракте).
	•	Админ/Гардиан: задаёт параметры риска, может поставить на паузу.

⸻

4) Высокоуровневый процесс (жизненный цикл сделки)
	1.	LP вносит базовый актив и получает шары Vault (mint).
	2.	Backend мониторит: как только цена на DEX выгоднее протокольной цены анстейка (с учётом комиссий/газ/слippage/времени), он вызывает сделку.
	3.	Vault покупает стейк‑токен на DEX → сразу подаёт заявку на анстейк в протокол.
	4.	Ожидание T (например, 7 дней): актив находится «в очереди на разлок».
	5.	Клейм: Vault получает базовый актив по «идеальной» цене, фиксирует прибыль, увеличивая NAV.
	6.	LP может выводить базовый актив через redeem (или продолжать компаундинг).

⸻

5) Экономика и формулы

5.1. Условие входа в сделку (проверка прибыли в контракте)
	•	Пусть:
	•	P_{\text{dex}} — цена покупки 1 стейк‑токена в базовом активе на DEX.
	•	P_{\text{unstake}} — ожидаемые поступления в базовом активе за 1 стейк‑токен при протокольном анстейке (после всех протокольных комиссий).
	•	c_{\text{gas}} — совокупные газ‑расходы сделки, пересчитанные в базовый актив, на единицу объёма.
	•	\sigma — фактическая проскальзывание (на входе/выходе), в долях.
	•	\Delta t — ожидаемая длительность анстейка в днях.
	•	r_{\text{min}} — требуемая минимальная годовая доходность (порог), учёт времени ожидания.

Сделка разрешена, если:
P_{\text{unstake}} - P_{\text{dex}}\,(1+\sigma) - c_{\text{gas}} \;\ge\; r_{\text{min}} \cdot \frac{\Delta t}{365}\cdot P_{\text{dex}}

5.2. Маржинальность одной сделки

m \;=\; \frac{P_{\text{unstake}} - P_{\text{dex}}(1+\sigma) - c_{\text{gas}}}{P_{\text{dex}}}
Если m \le 0 — сделка запрещена.

5.3. Ожидаемая годовая доходность LP

Пусть:
	•	U — средняя утилизация капитала (доля средств, реально работающих в сделках в среднем по году).
	•	\bar{m} — средняя маржинальность сделки.
	•	\bar{T} — средняя длительность сделки (в днях).
	•	f_{\text{perf}} — performance fee (доля от прибыли).

Тогда приближённо:
\text{APY}{\text{gross}} \;\approx\; U \cdot \bar{m} \cdot \frac{365}{\bar{T}}
\text{APY}{\text{net}} \;\approx\; \text{APY}{\text{gross}} \cdot (1 - f{\text{perf}})

Числовой пример (sUSDe):
Допустим сейчас P_{\text{unstake}} - P_{\text{dex}} \approx 0{,}30\% на окне ~7 дней, проскальзывание и газ пренебрежимо малы, а утилизация капитала U = 50\%.
Тогда:
\text{APY}_{\text{gross}} \approx 0{,}003 \times 0{,}5 \times \frac{365}{7} \approx 7{,}7\% \text{ годовых}
После комиссии 15% на прибыль — ~6,5% годовых для LP.
(Фактическая доходность зависит от частоты «окон» и доступной ликвидности на DEX.)

⸻

6) Пользовательский интерфейс контракта (поведение)

6.1. Депозит (стандартный mint)
	•	Базовый актив: USDe для Vault‑sUSDe; ETH для Vault‑wstETH.
	•	Функции: deposit(amount) или mint(shares) — стандартный ERC-4626 интерфейс.
	•	Шары минтятся немедленно по текущему PPS = NAV / totalSupply.
	•	Благодаря линейной амортизации прибыли (accruedGain через emissionRate) PPS растёт плавно, без скачков при клеймах.
	•	Входящий LP автоматически получает справедливую цену: если он вносит капитал в момент t, то в NAV уже учтена только та часть прибыли, которая начислена к моменту t, но не будущая прибыль от активных батчей.
	•	Комиссии на вход/выход: по умолчанию 0%.

6.2. Вывод (немедленный или с очередью при нехватке ликвидности)
	•	requestWithdraw(shares):
		○	Обновляется accruedGain (см. раздел 9).
		○	Считается текущий PPS = NAV / totalSupply.
		○	owed = shares × PPS.
		○	Шары сжигаются немедленно (S -= shares).
	•	Выплата:
		○	Если C >= owed: платим сразу полностью (C -= owed).
		○	Иначе: платим весь доступный C, остаток (owed − C) ставим в очередь R (обязательства).
	•	При любых поступлениях (unstake, новые депозиты) сначала гасится очередь R (FIFO), затем остаток идёт в C.
	•	Это исключает ситуацию, при которой выходящие получают будущую прибыль, не начисленную в NAV.

⸻

7) Архитектура и модули

7.1. Vault (ядро)
	•	Учёт активов и расчёт NAV по формуле: NAV(t) = C + P0 + G(t) − R (см. раздел 9).
	•	Минт/редим шар по справедливой стоимости через механизм очередей (deposit queue, withdrawal queue).
	•	Механизм accruedGain: прибыль от каждого батча амортизируется линейно (emissionRate), исключая скачки PPS и фронт‑ран.
	•	Управление батчами: открытие сделок, трекинг окончания, клейм и распределение поступлений.
	•	updateAccrual() вызывается при каждой мутирующей операции для актуализации начисленной прибыли.

7.2. CooldownManager (управление батчами без сброса таймеров)
	•	Проблема: некоторые протоколы стейкинга (например, Ethena sUSDe) хранят на адрес одну активную заявку cooldown; повторный вызов сбрасывает таймер.
	•	Решение: используем пул суб‑адресов (минимальные прокси или EOAs) — «локеры» Locker_1, Locker_2, ..., Locker_N.
	•	Каждый локер держит ровно один активный батч; Vault запускает очередной батч через следующий свободный локер.
	•	Таким образом погашения образуют «лестницу» без пересечений и сбросов таймеров.
	•	CooldownManager отвечает за маршрутизацию: выбор свободного локера, запуск cooldown, клейм после ETA.

7.3. Адаптеры протоколов стейкинга (plug‑in)

Для каждого стейк‑актива — свой адаптер:
	•	previewUnstake(amountStake) → (amountBase, etaSeconds)
	•	requestUnstake(amountStake) → claimId
	•	claim(claimId) → amountBaseReceived
	•	Учёт комиссий/лимитов/периодов протокола.

7.4. DEX‑адаптеры (маршрутизация)
	•	Поддержка агрегаторов и/или конкретных DEX (например, Uniswap/Cow/1inch).
	•	Защиты: maxSlippageBps, minOut, частичные исполнения.
	•	Возможность использования приватных релеев для защиты от MEV.

7.5. Кипер/Backend
	•	Мониторинг цен/очередей/ликвидности.
	•	Вызов executeArb(params) только когда он‑чейн проверки подтверждают прибыль.
	•	Планировщик клеймов по готовности eta.
	•	Мониторинг очереди выводов R и погашение при поступлении средств.

7.6. Роли и безопасность
	•	Admin/Governance: установка параметров риска, адресов адаптеров, пауза.
	•	Operator/Keeper: может только инициировать сделки, которые контракт проверит на прибыльность.
	•	Пауза/Аварийный режим: заморозка новых сделок, сохранение возможности клеймить и выводить.

⸻

8) Управление рисками и параметры

8.1. Пороговые параметры (per‑vault)
	•	minProfitBps — минимальная маржа на вход сделки.
	•	maxSlippageBps — допустимая просадка цены на DEX.
	•	fee{perf,mgmt} — комиссии (перф. по умолчанию, mgmt — опционально 0).

8.2. Учёт рисков
	•	Протокольный риск: задержки, стоп анстейка, очереди, возможные хэйркаты.
	•	Рыночный/ликвидностный риск: резкое сужение ликвидности → неполные исполнения.
	•	Операционный риск: ошибки кипера/агрегатора; смягчается он‑чейн проверкой прибыли и ограничением параметров.
	•	Gas/MEV: сделки через приватные релеев и ограничение газ‑цены.

8.3. Защита от «входа в последний момент» и MEV на NAV
	•	Линейная амортизация прибыли (accruedGain с emissionRate) — ключевая мера защиты: исключает скачки PPS при клеймах, прибыль начисляется равномерно во времени.
	•	Входящий LP в любой момент t получает PPS, который включает только начисленную к моменту t прибыль G(t), но не будущую прибыль от незавершённых батчей.
	•	Выходящий LP также получает только начисленную часть G(t): после сжигания его долей батчи продолжают амортизироваться для оставшихся LP.
	•	Благодаря плавному росту PPS «last-minute entry» и «just-in-time liquidity» атаки становятся невыгодными: нет момента, когда можно войти и сразу получить всю прибыль.
	•	Отсутствие оракулов/внешних цен: NAV строится на детерминированных величинах протокола (cost, mature, время), что исключает MEV на чтение/манипуляцию цен.

⸻

9) NAV и учёт активов

9.1. Основная формула NAV

NAV(t) = C + P0 + G(t) − R

Где (в единицах базового актива, например USDe):
	•	C — свободный баланс базового актива на Vault (ликвидные средства).
	•	P0 — сумма себестоимостей всех активных батчей: P0 = Σ cost_i (по всем незакрытым батчам).
	•	G(t) — начисленная на момент t часть прибыли от всех батчей.
	•	R — обязательства по очереди выводов (недоплаченная сумма тем, кто уже сжёг доли, но не получил полную выплату из‑за нехватки C).

Цена одной доли (PPS):
PPS(t) = NAV(t) / S
где S = totalSupply() долей Vault.

При бутстрапе (S = 0) используется PPS = 1.0.

9.2. Что такое «батч» (batch)

Батч — это одна открытая сделка арбитража:
	1.	Vault потратил cost_i базового актива на покупку sUSDe на DEX.
	2.	Запустил cooldown в протоколе стейкинга; протокол гарантирует вернуть mature_i базового актива после времени t1_i (например, через 7 дней).
	3.	Прибыль батча: gain_i = mature_i − cost_i.
	4.	Батч открывается в момент t0_i и закрывается (клеймится) в t1_i.

Для каждого батча хранится:
	•	cost_i — себестоимость.
	•	mature_i — гарантированное поступление.
	•	t0_i — timestamp начала cooldown.
	•	t1_i = t0_i + D — timestamp окончания (обычно D = 7 дней = 604,800 секунд).
	•	rate_i = gain_i / D — скорость начисления прибыли (в USDe/секунду).
	•	locker — адрес суб‑контракта (локера), который держит этот батч (см. 7.2).

9.3. Как считается G(t) — начисленная прибыль

Для каждого батча прибыль начисляется линейно от 0 до gain_i за время D:
w_i(t) = clamp((t − t0_i) / D, 0, 1)   — доля времени, прошедшего с начала батча

Начисленная прибыль от батча i:
G_i(t) = w_i(t) × gain_i

Суммарная начисленная прибыль от всех активных батчей:
G(t) = Σ G_i(t) = Σ w_i(t) × gain_i

9.4. Эффективная реализация через emissionRate (без перебора батчей)

Чтобы не перебирать все батчи при каждом чтении NAV, используем агрегаты:

Переменные состояния:
	•	emissionRate — суммарная скорость начисления прибыли от всех активных батчей: Σ rate_i (в USDe/сек × 10¹⁸).
	•	accruedGain — уже начисленная прибыль (интеграл): Σ w_i × gain_i на момент lastUpdate.
	•	lastUpdate — timestamp последнего обновления accruedGain.
	•	ends[] — список «событий окончания» батчей: (t1_i, rate_i); при достижении now ≥ t1_i уменьшаем emissionRate -= rate_i.

Алгоритм updateAccrual() — вызывается в каждой мутирующей функции:

function updateAccrual():
    if now > lastUpdate:
        accruedGain += emissionRate × (now − lastUpdate)
        lastUpdate = now
    
    // обработать все завершившиеся батчи
    while ends[head].t1 ≤ now:
        emissionRate -= ends[head].rate
        pop(ends[head])

Таким образом G(t) = accruedGain всегда актуален и считается за O(1) + O(число завершившихся батчей с прошлого вызова).

9.5. Открытие нового батча (после покупки на DEX и запуска cooldown)

После того как Vault выполнил своп USDe → sUSDe на DEX и запустил cooldown в протоколе:

cost_i — потраченная сумма USDe
mature_i — ожидаемое поступление USDe (из previewUnstake протокола)
gain_i = mature_i − cost_i
rate_i = gain_i / D

updateAccrual()   // сначала обновляем accruedGain
P0 += cost_i
emissionRate += rate_i
pushEnd(t1_i, rate_i)   // добавляем событие окончания батча в очередь

Важно: C не трогается здесь (средства уже потрачены на своп до этого момента). В учёте NAV cost_i компенсируется уменьшением C от свопа, так что NAV остаётся примерно неизменным (или чуть увеличивается на ожидаемую прибыль).

9.6. Клейм батча (получение mature_i от протокола)

Когда now ≥ t1_i, кипер вызывает unstake/claim для батча i:

updateAccrual()   // к этому моменту w_i = 1, весь gain_i уже в accruedGain

Vault получает mature_i в C:
C += mature_i
P0 -= cost_i

К этому моменту по батчу i:
	•	rate_i уже автоматически убран из emissionRate (через событие окончания при updateAccrual).
	•	Вся прибыль gain_i уже учтена в accruedGain.

NAV до клейма:
NAV = C_old + P0_old + accruedGain_old − R
    = C_old + cost_i + (accruedGain_old уже содержит весь gain_i) − R

NAV после клейма:
NAV = (C_old + mature_i) + (P0_old − cost_i) + accruedGain_old − R
    = C_old + mature_i + P0_old − cost_i + accruedGain_old − R
    = C_old + (cost_i + gain_i) + P0_old − cost_i + accruedGain_old − R
    = C_old + P0_old + gain_i + accruedGain_old − R

То есть NAV не изменяется (прибыль уже была учтена постепенно), PPS не скачет.

9.7. Порядок распределения поступлений

При поступлении средств от клеймов:
	1.	updateAccrual() — обновляем начисленную прибыль.
	2.	Получаем mature_i в C: C += mature_i, P0 -= cost_i.
	3.	Сначала гасим очередь выводов R (FIFO):
		○	Выплачиваем min(C, R) ожидающим в очереди.
		○	C -= выплаченное, R -= выплаченное.
	4.	Остаток C доступен для новых сделок (с учётом резервного буфера L_buffer, если задан).

Примечание: депозиты LP идут напрямую в C и также могут использоваться для погашения R перед запуском новых сделок.

9.8. Числовой пример

Начальное состояние:
C = 1,000 USDe, S = 1,000 долей, P0 = 0, accruedGain = 0, emissionRate = 0, R = 0
⇒ NAV = 1,000, PPS = 1.000

День 0, момент t0: открываем батч
	•	Потрачено на DEX: cost = 100 USDe (C уменьшился от свопа, теперь C = 900).
	•	Ожидаемое поступление: mature = 106 USDe.
	•	gain = 6 USDe, D = 7 дней = 604,800 сек.
	•	rate = 6 / 604,800 ≈ 9.92 × 10⁻⁶ USDe/сек (в контракте × 10¹⁸).

Обновляем состояние:
updateAccrual()   // accruedGain += 0 (время не прошло)
P0 += 100 → P0 = 100
emissionRate += rate → emissionRate = rate
pushEnd(t0 + 7d, rate)

NAV = C(900) + P0(100) + accruedGain(0) − R(0) = 1,000
PPS = 1,000 / 1,000 = 1.000   (не изменилась!)

День 3.5 (через 302,400 сек ≈ половина периода):
Кто‑то вызывает любую мутирующую функцию (например, requestWithdraw):

updateAccrual():
    elapsed = 302,400 сек
    accruedGain += rate × 302,400 ≈ 9.92e-6 × 302,400 ≈ 3.0 USDe
    lastUpdate = now

NAV = C(900) + P0(100) + accruedGain(3.0) − R(0) = 1,003.0
PPS = 1,003.0 / 1,000 ≈ 1.003

Если LP выводит 200 долей:
owed = 200 × 1.003 = 200.6 USDe
C (900) хватает → выплачиваем 200.6, C := 699.4, S := 800
NAV = 699.4 + 100 + 3.0 = 802.4
PPS для оставшихся = 802.4 / 800 ≈ 1.003 (честная цена!)

День 7 (t1, время клейма):
updateAccrual():
    elapsed = 604,800 сек (всего)
    accruedGain стал ≈ 6.0 USDe (весь gain начислен)
    emissionRate -= rate → emissionRate = 0 (батч завершён)

unstake():
    C += 106 → C = 699.4 + 106 = 805.4
    P0 -= 100 → P0 = 0

NAV = 805.4 + 0 + 6.0 − 0 = 811.4
PPS = 811.4 / 800 ≈ 1.01425

(если бы S всё ещё был 1000: PPS = 1006/1000 = 1.006 — но выше из‑за того, что 200 долей вышли раньше)

9.9. Защита честности LP

Ключевые свойства механики:
	•	Прибыль начисляется линейно во времени → PPS растёт плавно, без скачков при клеймах.
	•	Входящий LP получает текущий PPS = (C + P0 + G(t) − R) / S, где G(t) включает только начисленную к моменту t прибыль → невозможно «украсть» будущую прибыль от незавершённых батчей.
	•	Выходящий LP получает только начисленную часть G(t) на момент выхода → батчи продолжают амортизироваться для оставшихся участников.
	•	Несколько параллельных батчей: emissionRate суммирует скорости всех активных батчей; при пересекающихся батчах прибыль продолжает амортизироваться корректно.
	•	Отсутствие оракулов/внешних цен: mature_i фиксируется при открытии батча из гарантий протокола → NAV детерминирован и невосприимчив к MEV на чтение цен.
	•	Стандартный ERC-4626: deposit/mint/withdraw/redeem работают как ожидается, без дополнительных очередей или эпох, что упрощает интеграцию.

⸻

10) Комиссии и их начисление

10.1. Performance fee (комиссия с прибыли)
	•	Взимается из accruedGain в момент updateAccrual() или периодически.
	•	Расчёт через high‑water mark: берём комиссию только с прибыли сверх предыдущего максимума NAV/share.
	•	Начисление: минт новых долей на адрес feeRecipient:
		○	feeAmount = (accruedGain − уже взятая комиссия) × perfFeeBps / 10000
		○	feeShares = feeAmount × S / NAV   (чтобы не менять PPS для остальных LP)
	•	Альтернативно: можно брать комиссию сразу при открытии батча (вычесть из gain_i), тогда в accruedGain попадает уже «чистая» прибыль для LP.

10.2. Management fee (опционально, обычно 0%)
	•	Начисляется пропорционально времени: mgmtFee = NAV × mgmtFeeBps / 10000 / 365 дней.
	•	Также через минт долей, чтобы не влиять на PPS.

⸻

11) События/логирование (для аналитики и мониторинга)

11.1. Основные события
	•	BatchOpened(batchId, locker, cost, expectedMature, gain, t0, t1, rate) — открыт новый батч.
	•	BatchMatured(batchId, locker, actualReceived) — батч завершён и заклеймлен.
	•	AccrualUpdated(accruedGain, emissionRate, timestamp) — обновление начисленной прибыли.
	•	Deposit(user, amount, shares) — стандартное ERC-4626 событие депозита.
	•	Withdraw(user, amount, shares) — стандартное ERC-4626 событие вывода.
	•	WithdrawQueued(user, shares, owed, paidNow, queuedAmount) — частичная выплата, остаток в очереди R.
	•	WithdrawPaidFromQueue(user, amount) — выплата из очереди выводов R.
	•	FeesTaken(feeAmount, sharesMinted, feeRecipient) — взята комиссия.
	•	ParametersUpdated(...), Paused(), Unpaused()

11.2. Метрики для мониторинга (view-функции и off-chain)
	•	TVL = NAV в базовом активе.
	•	Utilization U = P0 / (C + P0 + G − R) — доля средств в активных сделках.
	•	Средняя маржа \bar{m} по завершённым батчам.
	•	Средняя длительность \bar{T} (от открытия до клейма).
	•	P&L: суммарный gain по клеймам vs. ожидаемый (для отслеживания протокольных штрафов/хэйркатов).
	•	accruedGain / totalGainExpected — доля начисленной прибыли.
	•	R (размер очереди выводов) — сумма обязательств перед LP, ожидающими выплаты.
	•	emissionRate — текущая скорость начисления прибыли (USDe/сек).
	•	Количество активных батчей, средний остаток времени до клеймов.
	•	PPS (текущий и исторический high-water mark).
	•	Расход газа на 1$ прибыли (анализ эффективности).

⸻

12) Примеры сценариев

12.1. sUSDe (базовый актив — USDe)
	•	На DEX: P_{\text{dex}} = 1{,}012 USDe за 1 sUSDe.
	•	Протокольный анстейк даёт P_{\text{unstake}} = 1{,}015 USDe/sUSDe.
	•	\Delta t = 7 дней, газ/прослип минимальны.

Маржа сделки:
m = \frac{1{,}015 - 1{,}012}{1{,}012} \approx 0{,}296\%

Если задействовали весь капитал 1 000 000 USDe:
	•	Куплено: \approx 988\,142{,}29 sUSDe.
	•	Клейм через 7 дней: \approx 1\,002\,964{,}43 USDe.
	•	Профит: \approx 2\,964{,}43 USDe за цикл.
При средней утилизации U=50\%: ~7,7% годовых (брутто), ~6,5% (нетто) при 15% perf‑fee.

12.2. wstETH (базовый актив — ETH)
	•	Покупка stETH/wstETH с дисконтом к 1 ETH.
	•	Заявка на анстейк в Lido‑подобном протоколе и клейм ETH по идеальной цене (после протокольных комиссий/очереди).
	•	Аналогичные формулы и проверки.

⸻

13) Ограничения и допущения
	•	Время анстейка D фиксированное для расчётов (например, 7 дней), но фактическое ETA может варьироваться из‑за очередей протокола; контракт не входит в сделки, если ETA > maxUnstakeTime.
	•	Размер сделки ограничен ликвидностью DEX и лимитами протокола.
	•	Для справедливости к LP профит амортизируется линейно (accruedGain) без скачков PPS.
	•	Предполагается, что протокол стейкинга выполняет обещания по mature_i; риски хэйркатов/штрафов учитываются в параметрах minProfitBps и резервах.
	•	Депозиты и выводы работают по стандарту ERC-4626 без дополнительных очередей на вход (только очередь выводов R при нехватке ликвидности).
	•	Точность расчётов: используется fixed-point арифметика (1e18), возможны округления на уровне wei.

⸻

14) Требования к безопасности

14.1. Общие меры
	•	Reentrancy‑guard на всех мутирующих функциях.
	•	Проверка допустимых роутеров/токенов, белые списки адаптеров (только админ может добавлять).
	•	Он‑чейн верификация прибыли до исполнения сделки (gain > minProfitBps × cost).
	•	Роли с минимально необходимыми правами; мультисиг для админа.
	•	Возможность экстренной паузы (останавливает новые сделки, но разрешает клеймы и выводы).
	•	Автоснимки состояний: для каждого батча хранится (cost, mature, t0, t1, rate, locker).

14.2. Инварианты (для формальной верификации и тестов)
	1.	NAV consistency: NAV(t) = C + P0 + accruedGain − R всегда корректен после updateAccrual().
	2.	Profit protection: нельзя открыть батч, если gain_i ≤ 0 или gain_i < minProfitBps × cost_i.
	3.	Shares conservation: сумма shares всех LP (totalSupply) + сожжённые = выпущенные; баланс строго отслеживается.
	4.	Withdrawal fairness: выходящий LP получает owed = shares × PPS(now), где PPS учитывает только accruedGain (начисленное), но не будущую прибыль.
	5.	Queue integrity: R ≥ 0; при поступлении средств R гасится первым (FIFO).
	6.	Accrual monotonicity: accruedGain никогда не уменьшается (кроме взятия комиссий или учёта убытков).
	7.	EmissionRate correctness: emissionRate = Σ rate_i для всех активных батчей; при t ≥ t1_i батч автоматически убирается из emissionRate.
	8.	Balance reconciliation: C (учётный) ≈ baseAsset.balanceOf(vault) с учётом транзитных средств и возможных прямых трансферов.
	9.	Locker isolation: каждый locker держит не более одного активного батча; повторный запуск cooldown на занятом локере запрещён.
	10.	Time consistency: lastUpdate ≤ block.timestamp; события ends[] отсортированы по t1.

⸻

15) Набор параметров по умолчанию (MVP)
	•	minProfitBps: 15–30 б.п. (зависит от газа и целевой доходности).
	•	maxSlippageBps: 5–20 б.п. по каждой ноге.
	•	depositCap: стартовый лимит по каждому Vault (например, 2–10 млн в базовом активе).
	•	maxUnstakeTime: 10 дней (для sUSDe) / 14 дней (для wstETH) — корректируемо.
	•	perfFee: 10–20% (по умолчанию 15%).
	•	mgmtFee: 0%.

⸻

16) Требования к backend/киперам
	•	Мониторинг:
	•	On‑chain: котировки/TVL/очереди протокола.
	•	Off‑chain: алерты по отклонению цен и просадкам ликвидности.
	•	Исполнение:
	•	Перед вызовом — локальная симуляция сделки со всеми параметрами.
	•	Отправка через приватные релеев (минимизация MEV).
	•	Клейм:
	•	Пулинг клеймов (батчи), оптимизация газа.
	•	Ретрай‑логика при временных ошибках.

⸻

17) Тест‑план (минимальный)

17.1. Базовая механика NAV и accruedGain
	1.	Один батч полного цикла: открытие → амортизация → клейм; проверка NAV/PPS на каждом этапе.
	2.	updateAccrual(): корректность начисления при разных временных интервалах, граничные случаи (now = lastUpdate, now >> t1).
	3.	Несколько параллельных батчей: пересекающиеся периоды, корректность суммирования emissionRate.
	4.	События окончания батчей: автоматическое удаление rate_i из emissionRate при t ≥ t1_i.

17.2. Депозиты и выводы
	5.	Deposit/mint: немедленный расчёт PPS и минт долей; проверка корректности NAV до и после.
	6.	Withdraw/redeem при достаточном C: немедленная выплата, корректный burn долей.
	7.	Withdraw при нехватке C: постановка в R, частичная выплата; последующее погашение R при поступлениях.
	8.	Очередь FIFO: несколько запросов на вывод, погашение в правильном порядке при клеймах.

17.3. Границы и защиты
	9.	Минимальная прибыль: попытка открыть батч с gain < minProfitBps × cost → revert.
	10.	Максимальное время анстейка: ETA > maxUnstakeTime → revert.
	11.	Максимальный slippage: превышение maxSlippageBps → revert (на уровне DEX-адаптера).
	12.	Попытка использовать занятый locker: должна быть проверка и выбор свободного.

17.4. Пауза и аварийные ситуации
	13.	Пауза: новые сделки запрещены, клеймы и выводы разрешены.
	14.	Unpause: возобновление нормальной работы.
	15.	Протокольный хэйркат: actualReceived < expectedMature → корректный учёт убытка.

17.5. Защита от MEV и фронт-рана
	16.	Входящий LP получает справедливый PPS: при депозите в момент t получает PPS с учётом только G(t), а не будущей прибыли; проверка через симуляцию депозита в разные моменты батча.
	17.	Выходящий LP получает только accruedGain: проверка, что будущая прибыль не выплачивается; батчи продолжают амортизироваться после выхода.
	18.	PPS не скачет при клейме: до и после клейма PPS должен быть примерно равен (с учётом линейной амортизации).
	19.	Last-minute entry невыгодна: вход перед самым клеймом не даёт мгновенной прибыли (тест с входом за 1 блок до клейма).

17.6. Комиссии
	20.	Performance fee: корректное начисление из accruedGain, high-water mark.
	21.	Management fee (если используется): линейное начисление по времени.
	22.	Отсутствие двойного начисления комиссий.

17.7. Инварианты (фаззинг)
	23.	Инвариант NAV = C + P0 + accruedGain − R после любой операции.
	24.	Инвариант totalSupply: сумма балансов всех LP + burned = minted.
	25.	Инвариант emissionRate: равен сумме всех активных rate_i.
	26.	Округления: dust не должен накапливаться; проверка на потери/прибавки из-за округлений.

⸻

18) Метрики успеха (KPI)
	•	TVL (Total Value Locked) = NAV в базовом активе.
	•	Средняя утилизация U = P0 / NAV (%).
	•	Средняя маржа сделки \bar{m} (б.п.) по завершённым батчам.
	•	Среднее время батча \bar{T} (дни): от открытия до клейма.
	•	APY (брутто/нетто) по факту клеймов: реализованная vs. ожидаемая доходность.
	•	Доля нерабочих средств (idle ratio) = C / NAV (%).
	•	Размер очереди выводов R (сумма обязательств перед LP, ожидающими выплаты).
	•	Доля начисленной прибыли: accruedGain / expectedTotalGain (%).
	•	Количество активных батчей и средний остаток времени до клеймов.
	•	Доля неудачных/отклонённых сделок (по он‑чейн проверкам прибыли).
	•	Расход газа на 1$ прибыли (эффективность).
	•	Слippage: фактический vs. ожидаемый при свопах на DEX.
	•	Протокольные штрафы: (expectedMature − actualReceived) / expectedMature (если > 0).

⸻

19) Открытые параметры к согласованию (до запуска)
	•	Точный список сетей и адреса протоколов/DEX/агрегаторов.
	•	Стартовые значения depositCap, minProfitBps, maxSlippageBps.
	•	Политика очереди на вывод (только «стандартный» или включать «мгновенный с рыночным риском»).
	•	Размер и получатель perf‑fee; наличие/отсутствие mgmt‑fee.
	•	Политика приватного роутинга (Flashbots/MEV‑Blocker и т.д.).

⸻

Краткое резюме

Immediate Unstaking Vault — это модульный ERC‑4626 пул на каждый стейк‑актив, который выкупает дисконт на DEX и погашает по протоколу с задержкой, распределяя профит LP в базовом активе.

Ключевые особенности механики:
	•	NAV = C + P0 + G(t) − R: детерминированный расчёт без оракулов, где прибыль G(t) начисляется линейно через emissionRate от каждого батча.
	•	Стандартный ERC-4626: deposit/mint/withdraw/redeem работают немедленно; линейная амортизация прибыли обеспечивает справедливое ценообразование без очередей на вход.
	•	Очередь выводов R: при нехватке ликвидности C выводы ставятся в очередь и погашаются при поступлении средств от клеймов (FIFO).
	•	CooldownManager с пулом локеров: каждый батч держится на отдельном суб-адресе, избегая сброса таймеров протокола.
	•	Защита от MEV и фронт-рана: отсутствие скачков PPS благодаря линейной амортизации; входящие и выходящие получают только начисленную к моменту t прибыль G(t), но не будущую.

Доход формируется из спрэда между DEX и протокольной ценой, а риск цены минимален, так как выход происходит по гарантированной протокольной цене. Контракт содержит он‑чейн проверки прибыльности, систему инвариантов и набор гибких параметров риска. По текущим рыночным наблюдениям (например, ~0,30% спрэд на 7 дней при утилизации ~50%) ориентир брутто‑доходности — ~7–8% годовых, нетто — ниже с учётом performance fee (10–15%).